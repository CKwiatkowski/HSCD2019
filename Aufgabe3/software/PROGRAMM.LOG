KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
15Jan2020-09:04:50

 Addr Code

 000                         CONSTANT IO_Port, 00
 000                         CONSTANT LED0, 01
 000                         CONSTANT LED1, 02
 000                         CONSTANT BNT0, 04
 000                         CONSTANT COM_Port, 01
 000                         CONSTANT TXD, 01
 000                         CONSTANT RXD, 01
 000                         CONSTANT SIXTEEN, 10
 000                         CONSTANT EIGHT, 08
 000                         CONSTANT RAM_DATA, 04
 000                         CONSTANT RAM_REG1, 02
 000                         CONSTANT RAM_REG2, 03
 000                         CONSTANT CTRL, 08                     ; done und start
 000                         CONSTANT PTR1, 09                     ; Bits 1 - 8
 000                         CONSTANT PTR2, 0A                     ; Bits 9 - 11
 000                         CONSTANT LEN, 0B
 000                         CONSTANT BLOCKSIZE, FF
 000                         ; Register Mapping
 000                         ; alle acht Register s0 bis s7 stehen der ISR zur Verfuegung
 000                         NAMEREG s0, IOR
 000                         NAMEREG s1, TMP
 000                         NAMEREG s2, CNTH
 000                         NAMEREG s3, CNTL
 000                         NAMEREG s4, RAMADDR_READ
 000                         NAMEREG s5, CORRECT_COUNTER
 000                         NAMEREG s7, BLOCK_CNT
 000                         NAMEREG s6, SORT_REG
 000                         ; alle acht Register s8 bis sF stehen der Main-Funktion zur Verfuegung
 000                         NAMEREG s8, CNT16
 000                         NAMEREG s9, CNT8
 000                         NAMEREG sA, DATA
 000                         NAMEREG sB, READ_REG
 000                         NAMEREG sC, STATEWRITE
 000                         NAMEREG sD, STATEREAD
 000                         NAMEREG sE, READY_TO_WRITE
 000                         NAMEREG sF, CNTR16
 000                         ; --------------------------------------------------------------------------------------------
 000                         ADDRESS 000
 000                         ; Hauptfunktion
 000  0A200           start: AND CNTH[s2], 00                      ; Initialisierung der Zaehlers ...
 001  0A300                  AND CNTL[s3], 00                      ; in der ISR
 002  00C00                  LOAD STATEWRITE[sC], 00               ; Setzt Zustand auf 0
 003  00400                  LOAD RAMADDR_READ[s4], 00
 004  2C403                  OUTPUT RAMADDR_READ[s4], RAM_REG2[03]
 005  00E01                  LOAD READY_TO_WRITE[sE], 01           ; Write-Erlaubnis sperren
 006  00810                  LOAD CNT16[s8], SIXTEEN[10]           ; Taktzähler auf 16 setzen
 007  00908                  LOAD CNT8[s9], EIGHT[08]              ; Bitzähler auf 8 setzen
 008  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ; Taktzähler auf 16 setzen
 009  00500                  LOAD CORRECT_COUNTER[s5], 00
 00A  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]     ;Blockzähler mit 16 initialisieren
 00B  2C409                  OUTPUT RAMADDR_READ[s4], PTR1[09]
 00C  2C40A                  OUTPUT RAMADDR_READ[s4], PTR2[0A]
 00D  00600                  LOAD SORT_REG[s6], 00
 00E  2C608                  OUTPUT SORT_REG[s6], CTRL[08]
 00F  3C001                  ENABLE INTERRUPT
 010                   loop: ; do nothing
 010  34010                  JUMP loop[010]
 011                         ; --------------------------------------------------------------------------------------------
 011                         ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 011               BNT0LED0: 
 011  04000                  INPUT IOR[s0], IO_Port[00]            ; IO-Port einlesen
 012  04100                  INPUT TMP[s1], IO_Port[00]            ; IO-Port einlesen
 013  0A104                  AND TMP[s1], BNT0[04]                 ; Zustand von BNT0 ermitteln
 014  2010E                  SR0 TMP[s1]                           ; auf die Position ...
 015  2010E                  SR0 TMP[s1]                           ; ... von LED0 verschieben
 016  0A002                  AND IOR[s0], LED1[02]                 ; Zustand von LED1 ermitteln
 017  0D010                  OR IOR[s0], TMP[s1]                   ; LED1 mit BNT0 konkatinieren
 018  2C000                  OUTPUT IOR[s0], IO_Port[00]           ; den neuen Wert ueber IO-Port ausgeben
 019  2A000                  RETURN
 01A                         ; --------------------------------------------------------------------------------------------
 01A                         ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 01A  18301           BLINK: ADD CNTL[s3], 01                      ; den 16-Bit-Zaehler ...
 01B  1A200                  ADDCY CNTH[s2], 00                    ; .. inkrementieren
 01C  35C20                  JUMP NC, BLINK0[020]                  ; kein Ueberlauf -> exit, sonst
 01D  04000                  INPUT IOR[s0], IO_Port[00]            ; IO-Port einlesen
 01E  0E002                  XOR IOR[s0], LED1[02]                 ; LED1 toggeln
 01F  2C000                  OUTPUT IOR[s0], IO_Port[00]           ; den neuen Wert ueber IO-Port ausgeben
 020  2A000          BLINK0: RETURN
 021                         ; --------------------------------------------------------------------------------------------
 021                         ; Subroutine, die Daten in das Ausgangsportal TXD schreibt
 021                  WRITE: 
 021  14E00                  COMPARE READY_TO_WRITE[sE], 00
 022  2B400                  RETURN NZ
 023  14500                  COMPARE CORRECT_COUNTER[s5], 00
 024  3502C                  JUMP Z, RESET_RAM[02C]
 025  14C00                  COMPARE STATEWRITE[sC], 00
 026  35031                  JUMP Z, WRITE_STARTBIT[031]
 027  14C01                  COMPARE STATEWRITE[sC], 01
 028  3503A                  JUMP Z, WRITE_DATA[03A]
 029  14C02                  COMPARE STATEWRITE[sC], 02
 02A  35044                  JUMP Z, WRITE_STOPBIT[044]
 02B  34051                  JUMP WRITE_IDLE[051]
 02C                         ; --------------------------------------------------------------------------------------------
 02C              RESET_RAM: 
 02C  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 02D  00500                  LOAD CORRECT_COUNTER[s5], 00
 02E  00400                  LOAD RAMADDR_READ[s4], 00
 02F  00E01                  LOAD READY_TO_WRITE[sE], 01
 030  2A000                  RETURN
 031                         ; --------------------------------------------------------------------------------------------
 031         WRITE_STARTBIT: 
 031  1C801                  SUB CNT16[s8], 01
 032  2B400                  RETURN NZ
 033  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen         ; 16 Takte abwarten
 034  2C402                  OUTPUT RAMADDR_READ[s4], RAM_REG1[02]
 035  04A04                  INPUT DATA[sA], RAM_DATA[04]
 036  0A000                  AND IOR[s0], 00
 037  2C001                  OUTPUT IOR[s0], COM_Port[01]
 038  00C01                  LOAD STATEWRITE[sC], 01
 039  2A000                  RETURN
 03A                         ; --------------------------------------------------------------------------------------------
 03A             WRITE_DATA: 
 03A  1C801                  SUB CNT16[s8], 01
 03B  2B400                  RETURN NZ
 03C  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen         ; 16 Takte abwarten
 03D  2CA01                  OUTPUT DATA[sA], COM_Port[01]         ; Datenregister auf Output setzen
 03E  20A0E                  SR0 DATA[sA]
 03F  1C901                  SUB CNT8[s9], 01                      ; Daten bitweise herausschreiben
 040  2B400                  RETURN NZ
 041  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 042  00C02                  LOAD STATEWRITE[sC], 02
 043  2A000                  RETURN
 044                         ; --------------------------------------------------------------------------------------------
 044          WRITE_STOPBIT: 
 044  1C801                  SUB CNT16[s8], 01
 045  2B400                  RETURN NZ
 046  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen
 047  00001                  LOAD IOR[s0], 01
 048  2C001                  OUTPUT IOR[s0], COM_Port[01]
 049  18401                  ADD RAMADDR_READ[s4], 01
 04A  00C03                  LOAD STATEWRITE[sC], 03
 04B  1C501                  SUB CORRECT_COUNTER[s5], 01
 04C  2B400                  RETURN NZ
 04D  00400                  LOAD RAMADDR_READ[s4], 00
 04E  00500                  LOAD CORRECT_COUNTER[s5], 00
 04F  00E01                  LOAD READY_TO_WRITE[sE], 01           ;Schreibsperre aktivieren
 050  2A000                  RETURN
 051                         ; --------------------------------------------------------------------------------------------
 051             WRITE_IDLE: 
 051  00C00                  LOAD STATEWRITE[sC], 00
 052  2A000                  RETURN
 053                         ; --------------------------------------------------------------------------------------------
 053                   READ: 
 053  14D00                  COMPARE STATEREAD[sD], 00
 054  3506F                  JUMP Z, READ_STARTBIT[06F]
 055  14D01                  COMPARE STATEREAD[sD], 01
 056  3505C                  JUMP Z, READ_DATA[05C]
 057  14D02                  COMPARE STATEREAD[sD], 02
 058  35077                  JUMP Z, READ_STOPBIT[077]
 059  14D03                  COMPARE STATEREAD[sD], 03
 05A  350A4                  JUMP Z, WAIT_SORT[0A4]
 05B  34084                  JUMP READ_IDLE[084]
 05C                         ; --------------------------------------------------------------------------------------------
 05C              READ_DATA: 
 05C  1CF01                  SUB CNTR16[sF], 01
 05D  2B400                  RETURN NZ
 05E  00F10                  LOAD CNTR16[sF], SIXTEEN[10]
 05F  04001                  INPUT IOR[s0], COM_Port[01]
 060  0DB00                  OR READ_REG[sB], IOR[s0]
 061  20B0C                  RR READ_REG[sB]                       ; Inhalt des Read-Registers nach links verschieben
 062  1C901                  SUB CNT8[s9], 01                      ; Daten bitweise herausschreiben
 063  2B400                  RETURN NZ
 064  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 065  00D02                  LOAD STATEREAD[sD], 02
 066                         ; change state
 066  2A000                  RETURN
 067                         ; --------------------------------------------------------------------------------------------
 067            CHECK_GROSS: 
 067  14B5B                  COMPARE READ_REG[sB], 5B              ; ist es größer als 5A?
 068  35C97                  JUMP NC, READ_INCORRECT[097]
 069  14B41                  COMPARE READ_REG[sB], 41              ; ist es kleiner als 41?
 06A  3586C                  JUMP C, CHECK_ZAHL[06C]
 06B  34089                  JUMP READ_CORRECT[089]
 06C                         ; --------------------------------------------------------------------------------------------
 06C             CHECK_ZAHL: 
 06C  14B3A                  COMPARE READ_REG[sB], 3A              ; ist es größer als 39
 06D  35C97                  JUMP NC, READ_INCORRECT[097]
 06E  34089                  JUMP READ_CORRECT[089]
 06F                         ; --------------------------------------------------------------------------------------------
 06F          READ_STARTBIT: 
 06F  04001                  INPUT IOR[s0], COM_Port[01]
 070  14000                  COMPARE IOR[s0], 00
 071  2B400                  RETURN NZ
 072  1C901                  SUB CNT8[s9], 01
 073  2B400                  RETURN NZ
 074  00908                  LOAD CNT8[s9], EIGHT[08]
 075  00D01                  LOAD STATEREAD[sD], 01
 076  2A000                  RETURN
 077                         ; --------------------------------------------------------------------------------------------
 077           READ_STOPBIT: 
 077  1CF01                  SUB CNTR16[sF], 01
 078  2B400                  RETURN NZ
 079  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 07A  04001                  INPUT IOR[s0], COM_Port[01]
 07B  14001                  COMPARE IOR[s0], 01
 07C  2B400                  RETURN NZ
 07D                         ; Bereich einschränken
 07D  14B30                  COMPARE READ_REG[sB], 30              ;ist es kleiner als #30?
 07E  35897                  JUMP C, READ_INCORRECT[097]
 07F  14B7B                  COMPARE READ_REG[sB], 7B              ;ist es größer als #7A?
 080  35C97                  JUMP NC, READ_INCORRECT[097]
 081                         ; Kleinbuchstabe
 081  14B61                  COMPARE READ_REG[sB], 61
 082  35867                  JUMP C, CHECK_GROSS[067]
 083  34089                  JUMP READ_CORRECT[089]
 084                         ; --------------------------------------------------------------------------------------------
 084              READ_IDLE: 
 084  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 085  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 086  0AD00                  AND STATEREAD[sD], 00
 087  0AB00                  AND READ_REG[sB], 00
 088  2A000                  RETURN
 089                         ; --------------------------------------------------------------------------------------------
 089           READ_CORRECT: 
 089  00D04                  LOAD STATEREAD[sD], 04
 08A  18501                  ADD CORRECT_COUNTER[s5], 01
 08B  2C402                  OUTPUT RAMADDR_READ[s4], RAM_REG1[02]
 08C  2CB04                  OUTPUT READ_REG[sB], RAM_DATA[04]
 08D  18401                  ADD RAMADDR_READ[s4], 01
 08E  1C701                  SUB BLOCK_CNT[s7], 01
 08F  2B400                  RETURN NZ
 090  00400                  LOAD RAMADDR_READ[s4], 00
 091  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 092  2C50B                  OUTPUT CORRECT_COUNTER[s5], LEN[0B]
 093  00601                  LOAD SORT_REG[s6], 01
 094  2C608                  OUTPUT SORT_REG[s6], CTRL[08]
 095  00D03                  LOAD STATEREAD[sD], 03
 096  2A000                  RETURN
 097                         ; --------------------------------------------------------------------------------------------
 097         READ_INCORRECT: 
 097  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 098  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 099  0AD00                  AND STATEREAD[sD], 00
 09A  0AB00                  AND READ_REG[sB], 00
 09B  1C701                  SUB BLOCK_CNT[s7], 01
 09C  2B400                  RETURN NZ
 09D  00400                  LOAD RAMADDR_READ[s4], 00
 09E  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 09F  2C50B                  OUTPUT CORRECT_COUNTER[s5], LEN[0B]
 0A0  00601                  LOAD SORT_REG[s6], 01
 0A1  2C608                  OUTPUT SORT_REG[s6], CTRL[08]
 0A2  00D03                  LOAD STATEREAD[sD], 03
 0A3  2A000                  RETURN
 0A4                         ; --------------------------------------------------------------------------------------------
 0A4              WAIT_SORT: 
 0A4  00600                  LOAD SORT_REG[s6], 00
 0A5  2C608                  OUTPUT SORT_REG[s6], CTRL[08]
 0A6  04608                  INPUT SORT_REG[s6], CTRL[08]
 0A7  14601                  COMPARE SORT_REG[s6], 01
 0A8  2B400                  RETURN NZ
 0A9  0AE00                  AND READY_TO_WRITE[sE], 00            ;Schreibsperre aufheben
 0AA  00D04                  LOAD STATEREAD[sD], 04
 0AB  2A000                  RETURN
 0AC                         ; --------------------------------------------------------------------------------------------
 300                         ADDRESS 300
 300                         ; Interrupt-Service-Routine
 300  30021             ISR: CALL WRITE[021]
 301  30053                  CALL READ[053]
 302  30011                  CALL BNT0LED0[011]
 303  3001A                  CALL BLINK[01A]
 304  38001                  RETURNI ENABLE
 305                         ; --------------------------------------------------------------------------------------------
 305                         ; Interrupt-Vektor
 3FF                         ADDRESS 3FF
 3FF  34300                  JUMP ISR[300]
