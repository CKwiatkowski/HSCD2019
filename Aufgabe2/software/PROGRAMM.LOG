KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
09Jan2020-10:55:14

 Addr Code

 000                         CONSTANT IO_Port, 00
 000                         CONSTANT LED0, 01
 000                         CONSTANT LED1, 02
 000                         CONSTANT BNT0, 04
 000                         CONSTANT COM_Port, 01
 000                         CONSTANT TXD, 01
 000                         CONSTANT RXD, 01
 000                         CONSTANT SIXTEEN, 10
 000                         CONSTANT EIGHT, 08
 000                         CONSTANT RAM_DATA, 04
 000                         CONSTANT RAM_REG1, 02
 000                         CONSTANT RAM_REG2, 03
 000                         CONSTANT BLOCKSIZE, FF
 000                         ; Register Mapping
 000                         ; alle acht Register s0 bis s7 stehen der ISR zur Verfuegung
 000                         NAMEREG s0, IOR
 000                         NAMEREG s1, TMP
 000                         NAMEREG s2, CNTH
 000                         NAMEREG s3, CNTL
 000                         NAMEREG s4, RAMADDR_READ
 000                         NAMEREG s5, CORRECT_COUNTER
 000                         NAMEREG s7, BLOCK_CNT
 000                         ;NAMEREG s6, CNTR8
 000                         ; alle acht Register s8 bis sF stehen der Main-Funktion zur Verfuegung
 000                         NAMEREG s8, CNT16
 000                         NAMEREG s9, CNT8
 000                         NAMEREG sA, DATA
 000                         NAMEREG sB, READ_REG
 000                         NAMEREG sC, STATEWRITE
 000                         NAMEREG sD, STATEREAD
 000                         NAMEREG sE, READY_TO_WRITE
 000                         NAMEREG sF, CNTR16
 000                         ; --------------------------------------------------------------------------------------------
 000                         ADDRESS 000
 000                         ; Hauptfunktion
 000  0A200           start: AND CNTH[s2], 00                      ; Initialisierung der Zaehlers ...
 001  0A300                  AND CNTL[s3], 00                      ; in der ISR
 002  00C00                  LOAD STATEWRITE[sC], 00               ; Setzt Zustand auf 0
 003  00400                  LOAD RAMADDR_READ[s4], 00
 004  2C403                  OUTPUT RAMADDR_READ[s4], RAM_REG2[03]
 005  00E01                  LOAD READY_TO_WRITE[sE], 01           ; Write-Erlaubnis sperren
 006  00810                  LOAD CNT16[s8], SIXTEEN[10]           ; Taktzähler auf 16 setzen
 007  00908                  LOAD CNT8[s9], EIGHT[08]              ; Bitzähler auf 8 setzen
 008  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ; Taktzähler auf 16 setzen
 009                         ;LOAD   CNTR8, EIGHT  ; Bitzähler auf 8 setzen
 009  00500                  LOAD CORRECT_COUNTER[s5], 00
 00A  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]     ;Blockzähler mit 16 initialisieren
 00B  3C001                  ENABLE INTERRUPT
 00C                   loop: ; do nothing
 00C  3400C                  JUMP loop[00C]
 00D                         ; --------------------------------------------------------------------------------------------
 00D                         ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D               BNT0LED0: 
 00D  04000                  INPUT IOR[s0], IO_Port[00]            ; IO-Port einlesen
 00E  04100                  INPUT TMP[s1], IO_Port[00]            ; IO-Port einlesen
 00F  0A104                  AND TMP[s1], BNT0[04]                 ; Zustand von BNT0 ermitteln
 010  2010E                  SR0 TMP[s1]                           ; auf die Position ...
 011  2010E                  SR0 TMP[s1]                           ; ... von LED0 verschieben
 012  0A002                  AND IOR[s0], LED1[02]                 ; Zustand von LED1 ermitteln
 013  0D010                  OR IOR[s0], TMP[s1]                   ; LED1 mit BNT0 konkatinieren
 014  2C000                  OUTPUT IOR[s0], IO_Port[00]           ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                  RETURN
 016                         ; --------------------------------------------------------------------------------------------
 016                         ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301           BLINK: ADD CNTL[s3], 01                      ; den 16-Bit-Zaehler ...
 017  1A200                  ADDCY CNTH[s2], 00                    ; .. inkrementieren
 018  35C1C                  JUMP NC, BLINK0[01C]                  ; kein Ueberlauf -> exit, sonst
 019  04000                  INPUT IOR[s0], IO_Port[00]            ; IO-Port einlesen
 01A  0E002                  XOR IOR[s0], LED1[02]                 ; LED1 toggeln
 01B  2C000                  OUTPUT IOR[s0], IO_Port[00]           ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000          BLINK0: RETURN
 01D                         ; --------------------------------------------------------------------------------------------
 01D                         ; Subroutine, die Daten in das Ausgangsportal TXD schreibt
 01D                  WRITE: 
 01D  14E00                  COMPARE READY_TO_WRITE[sE], 00
 01E  2B400                  RETURN NZ
 01F  14500                  COMPARE CORRECT_COUNTER[s5], 00
 020  35028                  JUMP Z, RESET_RAM[028]
 021  14C00                  COMPARE STATEWRITE[sC], 00
 022  3502D                  JUMP Z, WRITE_STARTBIT[02D]
 023  14C01                  COMPARE STATEWRITE[sC], 01
 024  35036                  JUMP Z, WRITE_DATA[036]
 025  14C02                  COMPARE STATEWRITE[sC], 02
 026  35040                  JUMP Z, WRITE_STOPBIT[040]
 027  3404D                  JUMP WRITE_IDLE[04D]
 028                         ; --------------------------------------------------------------------------------------------
 028              RESET_RAM: 
 028  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 029  00500                  LOAD CORRECT_COUNTER[s5], 00
 02A  00400                  LOAD RAMADDR_READ[s4], 00
 02B  00E01                  LOAD READY_TO_WRITE[sE], 01
 02C  2A000                  RETURN
 02D                         ; --------------------------------------------------------------------------------------------
 02D         WRITE_STARTBIT: 
 02D  1C801                  SUB CNT16[s8], 01
 02E  2B400                  RETURN NZ
 02F  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen         ; 16 Takte abwarten
 030  2C402                  OUTPUT RAMADDR_READ[s4], RAM_REG1[02]
 031  04A04                  INPUT DATA[sA], RAM_DATA[04]
 032  0A000                  AND IOR[s0], 00
 033  2C001                  OUTPUT IOR[s0], COM_Port[01]
 034  00C01                  LOAD STATEWRITE[sC], 01
 035  2A000                  RETURN
 036                         ; --------------------------------------------------------------------------------------------
 036             WRITE_DATA: 
 036  1C801                  SUB CNT16[s8], 01
 037  2B400                  RETURN NZ
 038  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen         ; 16 Takte abwarten
 039  2CA01                  OUTPUT DATA[sA], COM_Port[01]         ; Datenregister auf Output setzen
 03A  20A0E                  SR0 DATA[sA]
 03B  1C901                  SUB CNT8[s9], 01                      ; Daten bitweise herausschreiben
 03C  2B400                  RETURN NZ
 03D  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 03E  00C02                  LOAD STATEWRITE[sC], 02
 03F  2A000                  RETURN
 040                         ; --------------------------------------------------------------------------------------------
 040          WRITE_STOPBIT: 
 040  1C801                  SUB CNT16[s8], 01
 041  2B400                  RETURN NZ
 042  00810                  LOAD CNT16[s8], SIXTEEN[10]           ;Zaehler zurücksetzen
 043  00001                  LOAD IOR[s0], 01
 044  2C001                  OUTPUT IOR[s0], COM_Port[01]
 045  18401                  ADD RAMADDR_READ[s4], 01
 046  00C03                  LOAD STATEWRITE[sC], 03
 047  1C501                  SUB CORRECT_COUNTER[s5], 01
 048  2B400                  RETURN NZ
 049  00400                  LOAD RAMADDR_READ[s4], 00
 04A  00500                  LOAD CORRECT_COUNTER[s5], 00
 04B  00E01                  LOAD READY_TO_WRITE[sE], 01           ;Schreibsperre aktivieren
 04C  2A000                  RETURN
 04D                         ; --------------------------------------------------------------------------------------------
 04D             WRITE_IDLE: 
 04D  00C00                  LOAD STATEWRITE[sC], 00
 04E  2A000                  RETURN
 04F                         ; --------------------------------------------------------------------------------------------
 04F                   READ: 
 04F  14D00                  COMPARE STATEREAD[sD], 00
 050  35069                  JUMP Z, READ_STARTBIT[069]
 051  14D01                  COMPARE STATEREAD[sD], 01
 052  35056                  JUMP Z, READ_DATA[056]
 053  14D02                  COMPARE STATEREAD[sD], 02
 054  35071                  JUMP Z, READ_STOPBIT[071]
 055  3407E                  JUMP READ_IDLE[07E]
 056                         ; --------------------------------------------------------------------------------------------
 056              READ_DATA: 
 056  1CF01                  SUB CNTR16[sF], 01
 057  2B400                  RETURN NZ
 058  00F10                  LOAD CNTR16[sF], SIXTEEN[10]
 059  04001                  INPUT IOR[s0], COM_Port[01]
 05A  0DB00                  OR READ_REG[sB], IOR[s0]
 05B  20B0C                  RR READ_REG[sB]                       ; Inhalt des Read-Registers nach links verschieben
 05C  1C901                  SUB CNT8[s9], 01                      ; Daten bitweise herausschreiben
 05D  2B400                  RETURN NZ
 05E  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 05F  00D02                  LOAD STATEREAD[sD], 02
 060                         ; change state
 060  2A000                  RETURN
 061                         ; --------------------------------------------------------------------------------------------
 061            CHECK_GROSS: 
 061  14B5B                  COMPARE READ_REG[sB], 5B              ; ist es größer als 5A?
 062  35C8E                  JUMP NC, READ_INCORRECT[08E]
 063  14B41                  COMPARE READ_REG[sB], 41              ; ist es kleiner als 41?
 064  35866                  JUMP C, CHECK_ZAHL[066]
 065  34083                  JUMP READ_CORRECT[083]
 066                         ; --------------------------------------------------------------------------------------------
 066             CHECK_ZAHL: 
 066  14B3A                  COMPARE READ_REG[sB], 3A              ; ist es größer als 39
 067  35C8E                  JUMP NC, READ_INCORRECT[08E]
 068  34083                  JUMP READ_CORRECT[083]
 069                         ; --------------------------------------------------------------------------------------------
 069          READ_STARTBIT: 
 069  04001                  INPUT IOR[s0], COM_Port[01]
 06A  14000                  COMPARE IOR[s0], 00
 06B  2B400                  RETURN NZ
 06C  1C901                  SUB CNT8[s9], 01
 06D  2B400                  RETURN NZ
 06E  00908                  LOAD CNT8[s9], EIGHT[08]
 06F  00D01                  LOAD STATEREAD[sD], 01
 070  2A000                  RETURN
 071                         ; --------------------------------------------------------------------------------------------
 071           READ_STOPBIT: 
 071  1CF01                  SUB CNTR16[sF], 01
 072  2B400                  RETURN NZ
 073  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 074  04001                  INPUT IOR[s0], COM_Port[01]
 075  14001                  COMPARE IOR[s0], 01
 076  2B400                  RETURN NZ
 077                         ; Bereich einschränken
 077  14B30                  COMPARE READ_REG[sB], 30              ;ist es kleiner als #30?
 078  3588E                  JUMP C, READ_INCORRECT[08E]
 079  14B7B                  COMPARE READ_REG[sB], 7B              ;ist es größer als #7A?
 07A  35C8E                  JUMP NC, READ_INCORRECT[08E]
 07B                         ; Kleinbuchstabe
 07B  14B61                  COMPARE READ_REG[sB], 61
 07C  35861                  JUMP C, CHECK_GROSS[061]
 07D  34083                  JUMP READ_CORRECT[083]
 07E                         ; --------------------------------------------------------------------------------------------
 07E              READ_IDLE: 
 07E  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 07F  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 080  0AD00                  AND STATEREAD[sD], 00
 081  0AB00                  AND READ_REG[sB], 00
 082  2A000                  RETURN
 083                         ; --------------------------------------------------------------------------------------------
 083           READ_CORRECT: 
 083  00D03                  LOAD STATEREAD[sD], 03
 084  18501                  ADD CORRECT_COUNTER[s5], 01
 085  2C402                  OUTPUT RAMADDR_READ[s4], RAM_REG1[02]
 086  2CB04                  OUTPUT READ_REG[sB], RAM_DATA[04]
 087  18401                  ADD RAMADDR_READ[s4], 01
 088  1C701                  SUB BLOCK_CNT[s7], 01
 089  2B400                  RETURN NZ
 08A  00400                  LOAD RAMADDR_READ[s4], 00
 08B  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 08C  0AE00                  AND READY_TO_WRITE[sE], 00            ;Schreibsperre aufheben
 08D  2A000                  RETURN
 08E                         ; --------------------------------------------------------------------------------------------
 08E         READ_INCORRECT: 
 08E  00908                  LOAD CNT8[s9], EIGHT[08]              ; Zaehler zurücksetzen
 08F  00F10                  LOAD CNTR16[sF], SIXTEEN[10]          ;Zaehler zurücksetzen
 090  0AD00                  AND STATEREAD[sD], 00
 091  0AB00                  AND READ_REG[sB], 00
 092  1C701                  SUB BLOCK_CNT[s7], 01
 093  2B400                  RETURN NZ
 094  00400                  LOAD RAMADDR_READ[s4], 00
 095  007FF                  LOAD BLOCK_CNT[s7], BLOCKSIZE[FF]
 096  0AE00                  AND READY_TO_WRITE[sE], 00            ;Schreibsperre aufheben
 097  2A000                  RETURN
 098                         ; --------------------------------------------------------------------------------------------
 300                         ADDRESS 300
 300                         ; Interrupt-Service-Routine
 300  3001D             ISR: CALL WRITE[01D]
 301  3004F                  CALL READ[04F]
 302  3000D                  CALL BNT0LED0[00D]
 303  30016                  CALL BLINK[016]
 304  38001                  RETURNI ENABLE
 305                         ; --------------------------------------------------------------------------------------------
 305                         ; Interrupt-Vektor
 3FF                         ADDRESS 3FF
 3FF  34300                  JUMP ISR[300]
